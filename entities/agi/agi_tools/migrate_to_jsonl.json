{
  "$meta": {
    "artifact_id": "ArtifactID:Cx2ZB33pe3S4cV",
    "sha256": "7748fcba8335435606ace6b89122fbb7813c83d03d99c4835f77879c9763db1f",
    "issued": "2025-10-04T18:13:59Z",
    "path": "aci://entities/agi/agi_tools/migrate_to_jsonl.json"
  },
  "version": "1.0",
  "pipeline": "agi.memory.migrate_to_jsonl",
  "description": "Migrate legacy HiveMind exports into the policy-compliant AGI JSONL memory artifact, applying identity and governance checks.",
  "trigger": {
    "type": "cli",
    "pattern": "^aci\\s+memory\\s+migrate\\b",
    "notes": "Invoke via: aci memory migrate --input <legacy.json> --output-dir <memory/agi_memory/...>"
  },
  "steps": [
    {
      "call": "_args.require",
      "map": {
        "key": "input",
        "notes": "Path to the legacy export artifact that requires migration."
      }
    },
    {
      "call": "_args.require",
      "map": {
        "key": "output_dir",
        "notes": "Destination directory where the JSONL artifact and checksum should be written."
      }
    },
    {
      "call": "_args.get",
      "map": {
        "key": "policy",
        "default": "entities/agi/agi_export_policy.json",
        "notes": "Allow callers to override the export policy; defaults to agi_export_policy.json."
      }
    },
    {
      "call": "policy.load",
      "map": {
        "path": "$steps.2.value",
        "store_as": "policy",
        "notes": "Load agi_export_policy.json so downstream steps can use agi_memory metadata, filters, and audit requirements."
      }
    },
    {
      "call": "identity.resolve",
      "map": {
        "policy": "$state.policy",
        "identity_argument": "${args.identity}",
        "notes": "Resolve identity via agi_identity_manager.json honoring explicit --identity overrides and policy identity_source."
      }
    },
    {
      "call": "migrate.collect_messages",
      "map": {
        "input_path": "$steps.0.value",
        "notes": "Prefer the JSON-native migrate.collect_messages capability when available; parse the legacy payload and collect message-like records regardless of historical schema drift, falling back to the archived Python behavior only when required."
      }
    },
    {
      "call": "migrate.normalize_messages",
      "map": {
        "messages": "$steps.5.value",
        "notes": "Prefer the JSON-native migrate.normalize_messages capability when available so timestamps, roles, and metadata normalize into UTC Z-format schema-aligned keys, reserving the archived Python implementation as a compatibility fallback."
      }
    },
    {
      "call": "migrate.apply_filters",
      "map": {
        "messages": "$steps.6.value",
        "policy_filters": "$state.policy.agi_memory",
        "notes": "Prefer the JSON-native migrate.apply_filters capability when available and honor agi_memory allow_topics, deny_tags, drop_if_topic_missing, and default_topic directives before writing output, retaining the archived Python fallback solely for legacy environments."
      }
    },
    {
      "call": "migrate.apply_audit_requirements",
      "map": {
        "messages": "$steps.7.value",
        "audit": "$state.policy.agi_memory.audit",
        "notes": "Prefer the JSON-native migrate.apply_audit_requirements capability when available to enforce chronological ordering, inject export audit events, and prepare ledger metadata if required, relying on the archived Python implementation only when JSON support is unavailable."
      }
    },
    {
      "call": "migrate.write_jsonl",
      "map": {
        "messages": "$steps.8.value",
        "output_dir": "$steps.1.value",
        "policy": "$state.policy.agi_memory",
        "identity": "$steps.4.value",
        "path_template": "$state.policy.agi_memory.path_template",
        "filename_template": "$state.policy.agi_memory.filename_template",
        "timestamp_format": "$state.policy.agi_memory.timestamp_format",
        "notes": "Prefer the JSON-native migrate.write_jsonl capability when available to render the JSONL artifact using the path_template, filename_template, and timestamp_format defined in agi_memory, exposing the absolute artifact.path for downstream checksum and ledger steps while keeping the archived Python variant as a fallback."
      }
    },
    {
      "call": "migrate.write_checksum",
      "map": {
        "artifact": "$steps.9.value",
        "path": "$steps.9.value.path",
        "notes": "Prefer the JSON-native migrate.write_checksum capability when available to emit a SHA-256 checksum companion file for the generated JSONL artifact using the absolute artifact.path, deferring to the archived Python routine only when necessary."
      }
    },
    {
      "call": "migrate.append_ledger",
      "map": {
        "artifact": "$steps.9.value",
        "checksum": "$steps.10.value",
        "ledger_path": "$state.policy.agi_memory.audit.ledger_path",
        "notes": "Prefer the JSON-native migrate.append_ledger capability when available to append an anchoring record to the configured ledger when audit.ledger_path is present, using the archived Python logic only when JSON replacements are unavailable."
      }
    },
    {
      "call": "_format.json",
      "map": {
        "artifact": "$steps.9.value",
        "checksum": "$steps.10.value",
        "notes": "Return a machine-readable summary of the migration results."
      }
    }
  ]
}
